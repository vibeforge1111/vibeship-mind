"""Templates for Mind files (v2: daemon-free, MCP-driven)."""

SESSION_TEMPLATE = """# Session: {date}

## The Goal
<!-- USER OUTCOME, not technical task. What does success look like for the user? -->
<!-- Example: "User can upload images and see them in their gallery" -->
<!-- NOT: "Implement image upload endpoint" -->

## Current Approach
<!-- What you're trying RIGHT NOW. Include pivot condition. -->
<!-- Format: "Doing X. Pivot if: Y" -->
<!-- Example: "Using multer for uploads. Pivot if: memory issues with large files" -->

## Blockers
<!-- Things stopping progress. When you add here, SEARCH MEMORY for solutions. -->
<!-- Each blocker triggers: mind_search(blocker_keywords) -->

## Rejected Approaches
<!-- Strategic decisions, not tactical failures. Include WHY to prevent circles. -->
<!-- Format: "Approach - Why rejected" -->
<!-- Example: "Client-side resize - Quality loss unacceptable for photography app" -->

## Working Assumptions
<!-- Things you're assuming true. Question these when stuck. -->
<!-- Example: "User has stable internet" / "Files under 10MB" -->

## Discoveries
<!-- Findings that matter. Tech patterns get promoted to MEMORY.md on session end. -->
"""

MEMORY_TEMPLATE = """<!-- MIND MEMORY - Append as you work. Write naturally.
Keywords: decided, problem, learned, tried, fixed, blocked, KEY, important -->

# {project_name}

## Project State
- Goal:
- Stack: {stack}
- Blocked: None

## Gotchas
<!-- Project-specific gotchas -->

---

## Session Log

## {date}

(Start writing here)

<!-- End session with: ## DATE | summary of what happened | mood: X -->
---
"""

CONTEXT_TEMPLATE = """## Memory (Mind)

This project uses Mind for persistent memory across sessions.

### Required Protocol

1. **Session Start**: ALWAYS call `mind_recall()` before responding to the first message. This loads context from previous sessions.

2. **Long-Term Memory** (`.mind/MEMORY.md`): When you make decisions, hit issues, or learn gotchas, append directly:
   - `decided X because Y` - for decisions
   - `problem: X` - for issues
   - `learned that X` / `TIL: X` - for learnings
   - `gotcha: X` - for things that will bite again
   - `KEY: X` or `important: X` - for things that should never fade

3. **Session End**: Summarize with `## DATE | what happened | mood: X`

### Session Memory Protocol (`.mind/SESSION.md`)

Maintain `.mind/SESSION.md` during work to stay focused and avoid loops.

**The Goal** (set first, check often):
- Write the USER OUTCOME, not the technical task
- "User can X" not "Implement Y endpoint"
- Check this when you feel lost - are you still working toward it?

**Current Approach** (update as you pivot):
- What you're trying NOW + when to pivot
- Format: "Doing X. Pivot if: Y"
- When pivot condition hits, update approach, don't just keep trying

**Blockers** (triggers memory search):
- When you add a blocker, call `mind_blocker(description)`
- This auto-searches memory for solutions you might have forgotten
- If no solutions found, this is where you zoom out and ask user

**Rejected Approaches** (strategic, with WHY):
- Not "X didn't work" - that's tactical, it goes in memory
- This is "We're not doing X because [fundamental reason]"
- Check before proposing - don't re-propose rejected strategies

**Working Assumptions** (question when stuck):
- Things you're assuming true
- When stuck, review these - one might be wrong
- Invalidating an assumption = progress, not failure

**Discoveries** (promoted on session end):
- Useful findings during this session
- Tech patterns and file paths get promoted to MEMORY.md automatically

### Workflow

1. Start: Set The Goal (user outcome)
2. Plan: Set Current Approach with pivot condition
3. Work: Add discoveries as you go
4. Stuck?
   - Add to Blockers (triggers memory search)
   - Check Working Assumptions (one might be wrong)
   - Check Current Approach pivot condition (time to pivot?)
5. Pivot: Update Current Approach, add to Rejected if strategic
6. Done: Discoveries get promoted to MEMORY.md

### Tools Available

- `mind_recall()` - Load session context (CALL FIRST!)
- `mind_session()` - Get current session state
- `mind_blocker(description)` - Log blocker + auto-search memory for solutions
- `mind_search(query)` - Find specific memories
- `mind_checkpoint()` - Force process pending memories
- `mind_edges(intent)` - Check for gotchas before coding
- `mind_status()` - Check memory health

---

<!-- MIND:CONTEXT - Auto-generated by Mind. Do not edit. -->
## Stack
{stack}

## Gotchas
(None yet - add to .mind/MEMORY.md Gotchas section)
<!-- MIND:END -->"""

GITIGNORE_CONTENT = """.index/
state.json
"""
