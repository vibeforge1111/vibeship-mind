# Python Craftsman Collaboration Model
# How this skill works with other AI memory specialists

prerequisites:
  skills: []
  knowledge:
    - "Python 3.10+ syntax (match, union types)"
    - "Basic async/await understanding"
    - "Package management concepts"
    - "Type hint basics"

complementary_skills:
  - skill: api-designer
    relationship: "API implementation"
    brings: "FastAPI routes, request/response models, validation"

  - skill: test-architect
    relationship: "Python testing"
    brings: "pytest patterns, fixtures, async testing"

  - skill: data-engineer
    relationship: "Data processing"
    brings: "Pandas patterns, ETL code, data validation"

  - skill: sdk-builder
    relationship: "Library design"
    brings: "Public API design, packaging, documentation"

  - skill: performance-hunter
    relationship: "Python performance"
    brings: "Profiling, optimization, memory management"

  - skill: docs-engineer
    relationship: "Documentation"
    brings: "Docstrings, API docs, type documentation"

delegation:
  - trigger: "API endpoint design"
    delegate_to: api-designer
    pattern: parallel
    context: "Endpoint requirements"
    receive: "Route structure and schemas"

  - trigger: "test strategy for Python code"
    delegate_to: test-architect
    pattern: sequential
    context: "Code to be tested"
    receive: "Test plan with fixtures"

  - trigger: "data processing pipeline"
    delegate_to: data-engineer
    pattern: parallel
    context: "Data transformation needs"
    receive: "Pipeline design"

  - trigger: "public library API"
    delegate_to: sdk-builder
    pattern: sequential
    context: "Library purpose and users"
    receive: "API surface design"

  - trigger: "performance bottleneck"
    delegate_to: performance-hunter
    pattern: sequential
    context: "Slow code or memory issues"
    receive: "Profiling results and recommendations"

  - trigger: "documentation needs"
    delegate_to: docs-engineer
    pattern: parallel
    context: "What to document"
    receive: "Documentation structure"

collaboration_patterns:
  sequential:
    - "I design models, then api-designer creates routes"
    - "I write code, then test-architect designs tests"
    - "I optimize, then performance-hunter validates"

  parallel:
    - "I write implementation while docs-engineer writes docs"
    - "I build core while sdk-builder designs public API"

  review:
    - "Review api-designer's FastAPI code for Python patterns"
    - "Review test-architect's fixtures for proper async handling"
    - "Review data-engineer's code for type safety"

cross_domain_insights:
  - domain: rust
    insight: "Result<T, E> pattern makes errors explicit in types"
    applies_when: "Designing error handling without exceptions"

  - domain: functional-programming
    insight: "Immutable by default prevents unexpected state changes"
    applies_when: "Designing data models (frozen dataclasses, Pydantic)"

  - domain: go
    insight: "Explicit is better than implicit (no exceptions, interfaces)"
    applies_when: "Designing clear function contracts"

  - domain: java
    insight: "Interface segregation keeps dependencies minimal"
    applies_when: "Designing class hierarchies and protocols"

  - domain: unix-philosophy
    insight: "Do one thing well, compose larger from smaller"
    applies_when: "Designing modules and functions"

ecosystem:
  primary_tools:
    - "uv - Fast Python package manager"
    - "ruff - Fast linter and formatter"
    - "mypy - Static type checker"
    - "pytest - Testing framework"
    - "pydantic - Data validation"

  alternatives:
    - name: poetry
      use_when: "Need mature dependency resolution"
      avoid_when: "Speed is priority (uv is 10x faster)"

    - name: black
      use_when: "Team already using it"
      avoid_when: "Starting fresh (ruff includes formatter)"

    - name: pyright
      use_when: "Need faster type checking, VS Code integration"
      avoid_when: "Need strictest Python type checking"

    - name: hatch
      use_when: "Need build system with environment management"
      avoid_when: "Simple projects (uv is simpler)"

    - name: attrs
      use_when: "Need more control than dataclasses"
      avoid_when: "Pydantic validation is needed"

  deprecated:
    - "setup.py for modern packages"
    - "requirements.txt without lock files"
    - "Python 3.8 (end of life)"
    - "typing.Optional instead of X | None"
    - "Union[X, Y] instead of X | Y"
    - "Dict, List, Tuple from typing instead of builtins"

# Mind v5 Specific Context
mind_v5_specific:
  primary_responsibility: Python code quality and idioms
  pod: interface
  python_standards:
    version: "3.12+"
    type_checking: "mypy --strict"
    formatter: "ruff format"
    linter: "ruff check"
  critical_patterns:
    dataclasses:
      - "@dataclass(frozen=True) for events and memories"
      - "@dataclass(slots=True) for performance"
      - "Use field(default_factory=list) not = []"
    type_hints:
      - "All public functions typed"
      - "Use X | None not Optional[X]"
      - "Use generics for reusable code"
    async:
      - "async def for all I/O"
      - "asyncio.gather for concurrent operations"
      - "Never mix sync/async in same code path"
    error_handling:
      - "Result[T] over exceptions for expected failures"
      - "Specific exception types, never bare except"
      - "Error context in MindError.context dict"
  mind_v5_idioms:
    events:
      example: |
        @dataclass(frozen=True)
        class MemoryExtracted:
            memory_id: UUID
            user_id: UUID
            correlation_id: UUID
            causation_id: UUID
            content_hash: str
            temporal_level: TemporalLevel
            occurred_at: datetime
    memory:
      example: |
        @dataclass(frozen=True, slots=True)
        class Memory:
            memory_id: UUID
            user_id: UUID
            temporal_level: TemporalLevel
            base_salience: float
            outcome_adjustment: float = 0.0

            @property
            def effective_salience(self) -> float:
                return max(0.0, min(1.0, self.base_salience + self.outcome_adjustment))
    result:
      example: |
        @dataclass
        class Result(Generic[T]):
            value: T | None = None
            error: MindError | None = None

            @classmethod
            def ok(cls, value: T) -> Result[T]:
                return cls(value=value)

            @classmethod
            def err(cls, error: MindError) -> Result[T]:
                return cls(error=error)
  delegation:
    - trigger: "API endpoint implementation"
      delegate_to: api-designer
      pattern: parallel
      context: "Endpoint requirements and schemas"
      receive: "FastAPI route structure"

    - trigger: "test strategy for Mind v5 code"
      delegate_to: test-architect
      pattern: sequential
      context: "Code requiring tests"
      receive: "pytest fixtures and test plan"

    - trigger: "performance bottleneck in Python"
      delegate_to: performance-hunter
      pattern: sequential
      context: "Slow code location"
      receive: "Profiling and optimization suggestions"
