"""CLAUDE.md context injection and generation."""

import re
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional

from .parser import Entity, EntityType, IssueStatus, ParseResult
from .templates import CONTEXT_TEMPLATE


def generate_context(stack: list[str]) -> str:
    """Generate basic MIND:CONTEXT section (used by init)."""
    stack_str = ", ".join(stack) if stack else "(not detected)"
    return CONTEXT_TEMPLATE.format(stack=stack_str)


def update_claude_md(project_path: Path, stack: list[str]) -> None:
    """Add/update MIND:CONTEXT section in CLAUDE.md (basic version)."""
    claude_md = project_path / "CLAUDE.md"
    context = generate_context(stack)
    _inject_context(claude_md, context)


def _inject_context(claude_md: Path, context: str) -> None:
    """Inject context into CLAUDE.md file."""
    if claude_md.exists():
        content = claude_md.read_text()

        # Remove existing MIND:CONTEXT section
        content = re.sub(
            r"<!-- MIND:CONTEXT.*?<!-- MIND:END -->\n*",
            "",
            content,
            flags=re.DOTALL,
        )

        # Inject at top
        content = context + "\n\n" + content.lstrip()
    else:
        # Create new CLAUDE.md
        content = context + "\n\n# Project Instructions\n\n(Add your instructions here)\n"

    # Write atomically
    temp_path = claude_md.with_suffix(".md.tmp")
    temp_path.write_text(content)
    temp_path.replace(claude_md)


class ContextGenerator:
    """Generates rich MIND:CONTEXT from parsed entities."""

    def __init__(
        self,
        max_decisions: int = 5,
        max_open_loops: int = 3,
        max_gotchas: int = 5,
        stale_days: int = 14,
    ):
        self.max_decisions = max_decisions
        self.max_open_loops = max_open_loops
        self.max_gotchas = max_gotchas
        self.stale_days = stale_days

    def generate(
        self,
        parse_result: ParseResult,
        last_activity: Optional[datetime] = None,
    ) -> str:
        """Generate full MIND:CONTEXT section."""
        sections = []

        # Memory status
        sections.append(self._memory_status(last_activity))

        # Session context
        if last_activity:
            sections.append(self._session_context(last_activity))

        # Project state
        sections.append(self._project_state(parse_result))

        # Recent decisions
        decisions_section = self._recent_decisions(parse_result.entities)
        if decisions_section:
            sections.append(decisions_section)

        # Open loops
        loops_section = self._open_loops(parse_result.entities)
        if loops_section:
            sections.append(loops_section)

        # Gotchas
        gotchas_section = self._gotchas(parse_result.project_edges)
        if gotchas_section:
            sections.append(gotchas_section)

        # Continue from
        continue_section = self._continue_from(parse_result.entities)
        if continue_section:
            sections.append(continue_section)

        content = "\n\n".join(filter(None, sections))
        return f"<!-- MIND:CONTEXT - Auto-generated by Mind. Do not edit. -->\n{content}\n<!-- MIND:END -->"

    def _memory_status(self, last_activity: Optional[datetime]) -> str:
        """Generate memory status line."""
        if last_activity:
            ago = self._time_ago(last_activity)
            return f"## Memory: Active\nLast captured: {ago}"
        return "## Memory: Active"

    def _session_context(self, last_activity: datetime) -> str:
        """Generate session context."""
        ago = self._time_ago(last_activity)
        return f"## Session Context\nLast active: {ago}"

    def _project_state(self, result: ParseResult) -> str:
        """Generate project state section."""
        state = result.project_state
        lines = ["## Project State"]

        if state.goal:
            lines.append(f"- Goal: {state.goal}")
        if state.stack:
            lines.append(f"- Stack: {', '.join(state.stack)}")
        if state.blocked_by:
            lines.append(f"- Blocked: {state.blocked_by}")
        else:
            lines.append("- Blocked: None")

        return "\n".join(lines)

    def _recent_decisions(self, entities: list[Entity]) -> Optional[str]:
        """Generate recent decisions section."""
        decisions = [
            e for e in entities
            if e.type == EntityType.DECISION
        ]

        # Sort by date (most recent first), then by line number
        decisions.sort(
            key=lambda e: (e.date or datetime.min.date(), e.source_line),
            reverse=True,
        )

        decisions = decisions[:self.max_decisions]

        if not decisions:
            return None

        lines = ["## Recent Decisions"]
        for d in decisions:
            date_str = f" ({d.date})" if d.date else ""
            reason_str = f" - {d.reasoning}" if d.reasoning else ""
            lines.append(f"- {d.title}{date_str}{reason_str}")

        return "\n".join(lines)

    def _open_loops(self, entities: list[Entity]) -> Optional[str]:
        """Generate open loops section (unfinished business)."""
        loops = []

        # Open issues
        open_issues = [
            e for e in entities
            if e.type == EntityType.ISSUE and e.status == IssueStatus.OPEN
        ]

        for issue in open_issues[:self.max_open_loops]:
            date_str = f" ({issue.date})" if issue.date else ""
            loops.append(f"- [!] {issue.title}{date_str} - unresolved")

        # Stale decisions (MVP, temporary, etc.)
        now = datetime.now().date()
        for entity in entities:
            if entity.type != EntityType.DECISION:
                continue
            if not entity.date:
                continue

            age_days = (now - entity.date).days
            if age_days < self.stale_days:
                continue

            content_lower = entity.content.lower()
            if any(marker in content_lower for marker in ["mvp", "for now", "temporary", "quick fix"]):
                loops.append(f"- [?] {entity.title} ({age_days}d ago) - still valid?")

        if not loops:
            return None

        return "## Open Loops\n" + "\n".join(loops[:self.max_open_loops])

    def _gotchas(self, edges: list) -> Optional[str]:
        """Generate gotchas section."""
        if not edges:
            return None

        lines = ["## Gotchas"]
        for edge in edges[:self.max_gotchas]:
            if edge.workaround:
                lines.append(f"- {edge.title} -> {edge.workaround}")
            else:
                lines.append(f"- {edge.title}")

        return "\n".join(lines)

    def _continue_from(self, entities: list[Entity]) -> Optional[str]:
        """Generate continue from section."""
        # Find most recent decision or learning
        recent = None
        for entity in entities:
            if entity.type in (EntityType.DECISION, EntityType.LEARNING):
                if recent is None or (entity.date and (not recent.date or entity.date > recent.date)):
                    recent = entity

        if not recent:
            return None

        return f"## Continue From\nLast: {recent.title}"

    def _time_ago(self, dt: datetime) -> str:
        """Format datetime as relative time."""
        now = datetime.now()
        diff = now - dt

        if diff < timedelta(minutes=1):
            return "just now"
        elif diff < timedelta(hours=1):
            mins = int(diff.total_seconds() / 60)
            return f"{mins}m ago"
        elif diff < timedelta(days=1):
            hours = int(diff.total_seconds() / 3600)
            return f"{hours}h ago"
        else:
            days = diff.days
            return f"{days}d ago"

    def update_claude_md(self, project_path: Path, parse_result: ParseResult, last_activity: Optional[datetime] = None) -> None:
        """Update CLAUDE.md with rich context."""
        claude_md = project_path / "CLAUDE.md"
        context = self.generate(parse_result, last_activity)
        _inject_context(claude_md, context)
